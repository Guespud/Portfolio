"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _gatsbyCoreUtils = require("gatsby-core-utils");

var _terminalLink = _interopRequireDefault(require("terminal-link"));

var _chalk = _interopRequireDefault(require("chalk"));

const terminalLink = (text, url) => {
  if (process.env.NODE_ENV === `test`) {
    return `${text} (${url})`;
  } else {
    return (0, _terminalLink.default)(text, url);
  }
};

const handleFlags = (flags, configFlags, executingCommand = process.env.gatsby_executing_command) => {
  // Prepare config flags.
  // Filter out any flags that are set to false.
  const availableFlags = new Map();
  flags.forEach(flag => availableFlags.set(flag.name, flag));
  let enabledConfigFlags = Object.keys(configFlags).filter(name => configFlags[name] && availableFlags.has(name)).map(flagName => availableFlags.get(flagName)); // If we're in CI, filter out any flags that don't want to be enabled in CI

  if ((0, _gatsbyCoreUtils.isCI)()) {
    enabledConfigFlags = enabledConfigFlags.filter(flag => flag.noCi !== true);
  } // Filter out any flags that aren't for this environment.


  enabledConfigFlags = enabledConfigFlags.filter(flag => flag.command === `all` || flag.command === executingCommand);

  const addIncluded = flag => {
    if (flag.includedFlags) {
      flag.includedFlags.forEach(includedName => {
        const incExp = flags.find(e => e.name == includedName);

        if (incExp) {
          enabledConfigFlags.push(incExp);
          addIncluded(incExp);
        }
      });
    }
  }; // Add to enabledConfigFlags any includedFlags


  enabledConfigFlags.forEach(flag => {
    addIncluded(flag);
  });
  enabledConfigFlags = _lodash.default.uniq(enabledConfigFlags); // TODO remove flags that longer exist.
  //  w/ message of thanks

  let message = ``; //  Create message about what flags are active.

  if (enabledConfigFlags.length > 0) {
    message = `The following flags are active:`;
    enabledConfigFlags.forEach(flag => {
      message += `\n- ${flag.name}`;

      if (flag.experimental) {
        message += ` · ${_chalk.default.white.bgRed.bold(`EXPERIMENTAL`)}`;
      }

      if (flag.umbrellaIssue) {
        message += ` · (${terminalLink(`Umbrella Issue`, flag.umbrellaIssue)})`;
      }

      message += ` · ${flag.description}`;
    }); // TODO renable once "gatsby flags` CLI command exists.
    // Suggest enabling other flags if they're not trying them all.
    // const otherFlagsCount = flags.length - enabledConfigFlags.length
    // if (otherFlagsCount > 0) {
    // message += `\n\nThere ${
    // otherFlagsCount === 1
    // ? `is one other flag`
    // : `are ${otherFlagsCount} other flags`
    // } available you can test — run "gatsby flags" to enable them`
    // }

    message += `\n`;
  }

  return {
    enabledConfigFlags,
    message
  };
};

var _default = handleFlags;
exports.default = _default;
//# sourceMappingURL=handle-flags.js.map