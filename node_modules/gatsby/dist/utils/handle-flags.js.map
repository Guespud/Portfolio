{"version":3,"sources":["../../src/utils/handle-flags.ts"],"names":["terminalLink","text","url","process","env","NODE_ENV","handleFlags","flags","configFlags","executingCommand","gatsby_executing_command","availableFlags","Map","forEach","flag","set","name","enabledConfigFlags","Object","keys","filter","has","map","flagName","get","noCi","command","addIncluded","includedFlags","includedName","incExp","find","e","push","_","uniq","message","length","experimental","chalk","white","bgRed","bold","umbrellaIssue","description"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAEA;;AAEA,MAAMA,YAAY,GAAG,CAACC,IAAD,EAAOC,GAAP,KAAuB;AAC1C,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAA0B,MAA9B,EAAqC;AACnC,WAAQ,GAAEJ,IAAK,KAAIC,GAAI,GAAvB;AACD,GAFD,MAEO;AACL,WAAO,2BAAiBD,IAAjB,EAAuBC,GAAvB,CAAP;AACD;AACF,CAND;;AAQA,MAAMI,WAAW,GAAG,CAClBC,KADkB,EAElBC,WAFkB,EAGlBC,gBAAgB,GAAGN,OAAO,CAACC,GAAR,CAAYM,wBAHb,KAIwC;AAC1D;AACA;AACA,QAAMC,cAAc,GAAG,IAAIC,GAAJ,EAAvB;AACAL,EAAAA,KAAK,CAACM,OAAN,CAAcC,IAAI,IAAIH,cAAc,CAACI,GAAf,CAAmBD,IAAI,CAACE,IAAxB,EAA8BF,IAA9B,CAAtB;AACA,MAAIG,kBAAkB,GAAGC,MAAM,CAACC,IAAP,CAAYX,WAAZ,EACtBY,MADsB,CACfJ,IAAI,IAAIR,WAAW,CAACQ,IAAD,CAAX,IAAqBL,cAAc,CAACU,GAAf,CAAmBL,IAAnB,CADd,EAEtBM,GAFsB,CAElBC,QAAQ,IAAIZ,cAAc,CAACa,GAAf,CAAmBD,QAAnB,CAFM,CAAzB,CAL0D,CAS1D;;AACA,MAAI,4BAAJ,EAAY;AACVN,IAAAA,kBAAkB,GAAGA,kBAAkB,CAACG,MAAnB,CAA0BN,IAAI,IAAIA,IAAI,CAACW,IAAL,KAAc,IAAhD,CAArB;AACD,GAZyD,CAc1D;;;AACAR,EAAAA,kBAAkB,GAAGA,kBAAkB,CAACG,MAAnB,CACnBN,IAAI,IAAIA,IAAI,CAACY,OAAL,KAAkB,KAAlB,IAA0BZ,IAAI,CAACY,OAAL,KAAiBjB,gBADhC,CAArB;;AAIA,QAAMkB,WAAW,GAAIb,IAAD,IAAgB;AAClC,QAAIA,IAAI,CAACc,aAAT,EAAwB;AACtBd,MAAAA,IAAI,CAACc,aAAL,CAAmBf,OAAnB,CAA2BgB,YAAY,IAAI;AACzC,cAAMC,MAAM,GAAGvB,KAAK,CAACwB,IAAN,CAAWC,CAAC,IAAIA,CAAC,CAAChB,IAAF,IAAUa,YAA1B,CAAf;;AACA,YAAIC,MAAJ,EAAY;AACVb,UAAAA,kBAAkB,CAACgB,IAAnB,CAAwBH,MAAxB;AACAH,UAAAA,WAAW,CAACG,MAAD,CAAX;AACD;AACF,OAND;AAOD;AACF,GAVD,CAnB0D,CA8B1D;;;AACAb,EAAAA,kBAAkB,CAACJ,OAAnB,CAA2BC,IAAI,IAAI;AACjCa,IAAAA,WAAW,CAACb,IAAD,CAAX;AACD,GAFD;AAIAG,EAAAA,kBAAkB,GAAGiB,gBAAEC,IAAF,CAAOlB,kBAAP,CAArB,CAnC0D,CAqC1D;AACA;;AAEA,MAAImB,OAAO,GAAI,EAAf,CAxC0D,CAyC1D;;AACA,MAAInB,kBAAkB,CAACoB,MAAnB,GAA4B,CAAhC,EAAmC;AACjCD,IAAAA,OAAO,GAAI,iCAAX;AACAnB,IAAAA,kBAAkB,CAACJ,OAAnB,CAA2BC,IAAI,IAAI;AACjCsB,MAAAA,OAAO,IAAK,OAAMtB,IAAI,CAACE,IAAK,EAA5B;;AACA,UAAIF,IAAI,CAACwB,YAAT,EAAuB;AACrBF,QAAAA,OAAO,IAAK,MAAKG,eAAMC,KAAN,CAAYC,KAAZ,CAAkBC,IAAlB,CAAwB,cAAxB,CAAuC,EAAxD;AACD;;AACD,UAAI5B,IAAI,CAAC6B,aAAT,EAAwB;AACtBP,QAAAA,OAAO,IAAK,OAAMpC,YAAY,CAAE,gBAAF,EAAmBc,IAAI,CAAC6B,aAAxB,CAAuC,GAArE;AACD;;AACDP,MAAAA,OAAO,IAAK,MAAKtB,IAAI,CAAC8B,WAAY,EAAlC;AACD,KATD,EAFiC,CAajC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAR,IAAAA,OAAO,IAAK,IAAZ;AACD;;AAED,SAAO;AAAEnB,IAAAA,kBAAF;AAAsBmB,IAAAA;AAAtB,GAAP;AACD,CA1ED;;eA4Ee9B,W","sourcesContent":["import _ from \"lodash\"\nimport { isCI } from \"gatsby-core-utils\"\nimport realTerminalLink from \"terminal-link\"\nimport { IFlag } from \"./flags\"\nimport chalk from \"chalk\"\n\nconst terminalLink = (text, url): string => {\n  if (process.env.NODE_ENV === `test`) {\n    return `${text} (${url})`\n  } else {\n    return realTerminalLink(text, url)\n  }\n}\n\nconst handleFlags = (\n  flags: Array<IFlag>,\n  configFlags: Record<string, boolean>,\n  executingCommand = process.env.gatsby_executing_command\n): { enabledConfigFlags: Array<IFlag>; message: string } => {\n  // Prepare config flags.\n  // Filter out any flags that are set to false.\n  const availableFlags = new Map()\n  flags.forEach(flag => availableFlags.set(flag.name, flag))\n  let enabledConfigFlags = Object.keys(configFlags)\n    .filter(name => configFlags[name] && availableFlags.has(name))\n    .map(flagName => availableFlags.get(flagName))\n\n  // If we're in CI, filter out any flags that don't want to be enabled in CI\n  if (isCI()) {\n    enabledConfigFlags = enabledConfigFlags.filter(flag => flag.noCi !== true)\n  }\n\n  // Filter out any flags that aren't for this environment.\n  enabledConfigFlags = enabledConfigFlags.filter(\n    flag => flag.command === `all` || flag.command === executingCommand\n  )\n\n  const addIncluded = (flag): void => {\n    if (flag.includedFlags) {\n      flag.includedFlags.forEach(includedName => {\n        const incExp = flags.find(e => e.name == includedName)\n        if (incExp) {\n          enabledConfigFlags.push(incExp)\n          addIncluded(incExp)\n        }\n      })\n    }\n  }\n  // Add to enabledConfigFlags any includedFlags\n  enabledConfigFlags.forEach(flag => {\n    addIncluded(flag)\n  })\n\n  enabledConfigFlags = _.uniq(enabledConfigFlags)\n\n  // TODO remove flags that longer exist.\n  //  w/ message of thanks\n\n  let message = ``\n  //  Create message about what flags are active.\n  if (enabledConfigFlags.length > 0) {\n    message = `The following flags are active:`\n    enabledConfigFlags.forEach(flag => {\n      message += `\\n- ${flag.name}`\n      if (flag.experimental) {\n        message += ` · ${chalk.white.bgRed.bold(`EXPERIMENTAL`)}`\n      }\n      if (flag.umbrellaIssue) {\n        message += ` · (${terminalLink(`Umbrella Issue`, flag.umbrellaIssue)})`\n      }\n      message += ` · ${flag.description}`\n    })\n\n    // TODO renable once \"gatsby flags` CLI command exists.\n    // Suggest enabling other flags if they're not trying them all.\n    // const otherFlagsCount = flags.length - enabledConfigFlags.length\n    // if (otherFlagsCount > 0) {\n    // message += `\\n\\nThere ${\n    // otherFlagsCount === 1\n    // ? `is one other flag`\n    // : `are ${otherFlagsCount} other flags`\n    // } available you can test — run \"gatsby flags\" to enable them`\n    // }\n\n    message += `\\n`\n  }\n\n  return { enabledConfigFlags, message }\n}\n\nexport default handleFlags\n"],"file":"handle-flags.js"}